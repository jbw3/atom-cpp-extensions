# TODO: fix after-function conflict with macros

'scopeName': 'source.cpp'
'name': 'C++14'

'fileTypes': [
    'cpp'
    'h'
    'hpp'
]

# control keywords
'patterns': [{
# preprocessor
  'begin': '(?=#)'
  'end': '\\n'
  'name': 'meta.preprocessor'

  # keywords
  'patterns': [{
    'include': '#line-comment'
  },

  {
    'include': '#block-comment'
  },

  {
    'include': '#numeric-literals'
  },

  {
    'include': '#language-constants'
  },

  {
    'match': '#\\s*(define|elif|else|endif|error|if|ifdef|ifndef|include|line|pragma|undef|warning)\\b'
    'name': 'keyword.control'
  },

  # quotes highlight (e.g. #include "math.h")
  {
    'begin': '"'
    'end': '"|\\n'
    'name': 'string.quoted.other'
  },

  # angle brackets highlight (e.g. #include <cmath>)
  {
    'begin': '<'
    'end': '>|\\n'
    'name': 'string.quoted.other'
  }]
},

{
  'include': '#block'
},

{
  'include': '#control-keywords'
},

{
  'include': '#operator-keywords'
},

{
  'include': '#cast-operator-keywords'
},

{
  'include': '#after-function'
},

{
  'include': '#deprecated-keywords'
},

{
  'include': '#storage-types'
},

{
  'include': '#storage-modifiers'
},

{
  'include': '#support-types'
},

{
  'include': '#language-variables'
},

{
  'include': '#language-constants'
},

{
  'include': '#block-comment'
},

{
  'include': '#line-comment'
},

{
  'include': '#numeric-literals'
},

{
  'include': '#string'
},

{
  'include': '#raw-string'
},

{
  'include': '#char-literals'
},

{
  'include': '#function'
},
{
  'include': '#class'
}]

'repository':
  # doxygen keywords
  'doxygen-keywords':
    'match': '[@\\\\](author|authors|brief|class|details|file|note|param|ref|return|returns|struct|todo|tparam)\\b'
    'name':  'comment.block.documentation'

  # line comment
  'line-comment':
    'begin': '(?=//)'
    'end': '\\n'
    'name': 'comment.line.double-slash'
    # doxygen
    'patterns': [{
      # start with "///" or "//!" but not "////"
      'begin': '(?<!/)(?=//(/[^/]|!))'
      'end': '(?=\\n)'
      'name': 'meta.documentation'
      'patterns': [{
          'include': '#doxygen-keywords'
      }]
    }]

  # block comment
  'block-comment':
    'begin': '(?=/\\*)'
    'end': '(?<!/)\\*/'
    'name': 'comment.block'
    # doxygen
    'patterns': [{
      # start with "/**" or "/*!" but not "/***"
      'begin': '(?=/\\*(\\*[^\\*]|!))'
      'end': '(?=\\*/)'
      'name': 'meta.documentation'
      'patterns': [{
          'include': '#doxygen-keywords'
      }]
    }]

  # block
  'block':
    'begin': '{'
    'end': '}'
    'name': 'meta.block.cpp'
    'patterns': [{
      'include': '$base'
    }]

  # control keywords
  # TODO: C++17: add concept and requires
  'control-keywords':
    'match': '\\b(?:alignas|alignof|asm|break|case|catch|continue|default|delete|do|else|explicit|export|extern|for|friend|goto|if|inline|namespace|new|noexcept|operator|private|protected|public|return|sizeof|static_assert|switch|throw|try|typedef|using|virtual|while)\\b'
    'name': 'keyword.control'

  # operator keywords
  'operator-keywords':
    'match': '\\b(?:and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq)\\b'
    'name': 'keyword.operator'

  # cast keywords
  'cast-operator-keywords':
    'match': '\\b(?:const_cast|dynamic_cast|reinterpret_cast|static_cast)\\b'
    'name': 'keyword.operator.cast'

  # special identifiers
  'special-identifiers':
    'match': '\\b(?:final|override)\\b'
    'name': 'keyword.control'

  # deprecated keywords
  'deprecated-keywords':
    'match': '\\bregister\\b'
    'name': 'invalid.deprecated'

  # storage types
  # NOTE: class, struct, and union are highlighted in '#class'
  'storage-types':
    'match': '\\b(?:auto|bool|char|char16_t|char32_t|decltype|double|enum|float|int|long|short|signed|template|thread_local|unsigned|void|wchar_t)\\b'
    'name': 'storage.type.cpp'

  # language constants
  'language-constants':
    'match': '\\b(?:false|nullptr|true)\\b'
    'name': 'constant.language.cpp'

  # storage modifiers
  'storage-modifiers':
    'match': '\\b(?:const|constexpr|mutable|static|thread_local|typename|volatile)\\b'
    'name': 'storage.modifier.cpp'

  # support types
  'support-types':
    'match': '\\b(?:int8_t|int16_t|int32_t|int64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|int_least8_t|int_least16_t|int_least32_t|int_least64_t|intmax_t|intptr_t|size_t|uint|uint8_t|uint16_t|uint32_t|uint64_t|uint_fast8_t|uint_fast16_t|uint_fast32_t|uint_fast64_t|uint_least8_t|uint_least16_t|uint_least32_t|uint_least64_t|uintmax_t|uintptr_t)\\b'
    'name': 'support.type'

  # language variables
  'language-variables':
    'match': '\\bthis\\b'
    'name': 'variable.language'

  # numeric literals
  'numeric-literals':
    'match': '(?<![\'\\.])(?:(?:(?:\\b\\d(?:[\\d\']*\\d)?\\.\\d(?:[\\d\']*\\d)?|\\B\\.\\d(?:[\\d\']*\\d)?)(?:[Ee][+-]?\\d(?:[\\d\']*\\d)?)?(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\\w*))?\\b|(?:\\b\\d(?:[\\d\']*\\d)?\\.)(?:\\B|(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\\w*))\\b|(?:[Ee][+-]?\\d(?:[\\d\']*\\d)?)(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\\w*))?\\b)|\\b\\d(?:[\\d\']*\\d)?(?:[Ee][+-]?\\d(?:[\\d\']*\\d)?)(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\\w*))?\\b)|\\b(?:(?:[1-9](?:[\\d\']*\\d)?|0(?:[0-7\']*[0-7])?|0[Xx][\\da-fA-F](?:[\\da-fA-F\']*[\\da-fA-F])?|0[Bb][01](?:[01\']*[01])?)(?:(?:l{1,2}|L{1,2})[uU]?|[uU](?:l{0,2}|L{0,2})|(?:i[fl]?|h|min|[mun]?s|_\\w*))?)\\b)(?!\\.)'
    'name': 'constant.numeric'

  # escape chars
  'escape-chars':
    'match': '\\\\(?:[\'"\\?\\\\abfnrtv]|[0-7]{1,3}|x[\\da-fA-F]+|u[\\da-fA-F]{4}|U[\\da-fA-F]{8})'
    'name':  'constant.character.escape.cpp'

  # invaild escape chars
  'invalid-escape-chars':
    'match': '\\\\(?:[^\'"\\?\\\\abfnrtvxuU0-7]|x[^\\da-fA-F]|u[\\da-fA-F]{0,3}[^\\da-fA-F]|U[\\da-fA-F]{0,7}[^\\da-fA-F])'
    'name':  'invalid.illegal.unknown-escape.cpp'

  # string
  'string':
    'begin': '(?:L|u8|u|U)?"'
    'beginCaptures':
      '0':
        'name':'punctuation.definition.string.begin.cpp'
    'end': '"'
    'endCaptures':
      '0':
        'name':'punctuation.definition.string.end.cpp'
    'name': 'string.quoted.double.cpp'
    'patterns': [{
      'include': '#escape-chars'
    },
    {
      'include': '#invalid-escape-chars'
    }]

  # raw string
  'raw-string':
    'begin': '(?:L|u8|u|U)?R"([^\\(\\)\\\\ ]{0,16})\\('
    'beginCaptures':
      '0':
        'name':'punctuation.definition.string.begin.cpp'
    'end': '\\)\\1"'
    'endCaptures':
      '0':
        'name':'punctuation.definition.string.end.cpp'
    'name': 'string.quoted.double.cpp'

  # char literals
  'char-literals':
    'begin': '(?:L|u|U)?\'' # TODO: C++17: add u8
    'beginCaptures':
      '0':
        'name':'punctuation.definition.string.begin.cpp'
    'end': '\''
    'endCaptures':
      '0':
        'name':'punctuation.definition.string.end.cpp'
    'name': 'string.quoted.single.cpp'
    'patterns': [{
      'include': '#escape-chars'
    },
    {
      'include': '#invalid-escape-chars'
    }]

  # function
  # TODO: match across newlines
  # TODO: don't match non-functions in between <>
  'function':
    'match': '(?:[_a-zA-Z]\\w*(?:\\s*<.*>\\s*)?::)*(?:[_a-zA-Z]\\w*(?:\\s*<.*>\\s*)?)\\s*\\('
    'name': 'meta.function.cpp'
    'captures':
      '0':
        'patterns': [{
          'begin': '<'
          'end': '>'
          'patterns': [{
            'include': '$base'
          }]
        },
        {
          'match': '[_a-zA-Z]\\w*'
          'name': 'entity.name.function'
        }]

  # after function
  'after-function':
    'begin': '\\)'
    'end': '(?=;|{)'
    'name': 'meta.after-function'
    'patterns': [{
      'include': '#block-comment'
    },
    {
      'include': '#line-comment'
    },
    {
      'include': '#control-keywords'
    },
    {
      'include': '#operator-keywords'
    },
    {
      'include': '#cast-operator-keywords'
    },
    {
      'include': '#special-identifiers'
    },
    {
      'include': '#storage-types'
    },
    {
      'include': '#storage-modifiers'
    },
    {
      'include': '#support-types'
    },
    {
      'include': '#language-constants'
    },
    {
      'include': '#language-variables'
    },
    {
      'include': '#numeric-literals'
    },
    {
      'include': '#string'
    },
    {
      'include': '#raw-string'
    },
    {
      'include': '#char-literals'
    },
    {
      'include': '#function'
    }]

  # class, struct, union
  # TODO: don't highlight words in template brackets (e.g. < >)
  'class':
    'begin': '\\b(class|struct|union)\\b'
    'beginCaptures':
      '1':
        'name': 'storage.type.cpp'
    'end': ';'
    'name': 'meta.class-struct-block.cpp'
    'patterns': [{
      'begin': '\\b([_a-zA-Z]\\w*)\\b'
      'beginCaptures':
        '1':
          'name': 'entity.name.type.cpp'
      'end': '(?=;|{)'
      'patterns': [{
        'include': '$base'
      },
      {
        'match': '\\b([_a-zA-Z]\\w*)\\b'
        'name': 'entity.name.type.inherited.cpp'
      }]
    },
    {
      'begin': '{'
      'end': '}'
      'patterns': [{
        'include': '$base'
      }]
    }]
